//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//
// DO NOT EDIT THIS FILE SINCE IT HAS BEEN GENERATED AUTOMATICALLY
//
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

///******************************************************************************
//*
//* (c) Copyright 1996-2000, Palmchip Corporation
//*
//* This document is an unpublished work protected under the copyright laws
//* of the United States containing the confidential, proprietary and trade
//* secret information of Palmchip Corporation. This document may not be
//* copied or reproduced in any form whatsoever without the express written
//* permission of Palmchip Corporation.
//*
//*******************************************************************************
//*
//*  File Name: sysc.h
//*     Author: Linda Yang
//*
//*******************************************************************************
//*
//* Revision History:
//*
//*      Date    Name  Comments
//*    --------  ---   ------------------------------------
//*    11/08/00  LYT   Created
//*
//*******************************************************************************/
//
///* FILE_DESC ******************************************************************/
////
//// Purpose:
////    This file contains the register addresses and the bit definitions for 
////    all the system and processor control related registers. 
////
//// Sp. Notes:
////
///******************************************************************************/
//
#ifndef SYSC_H
#define	SYSC_H	 0 
//
///*=====================*
// *  Include Files      *
// *=====================*/
//#include "pubdefs.h"
//#include "product.h"
//#include "mem_map.h"
//
//
///*=====================*
// *  Defines            *
// *=====================*/
///* Define register offsets which are needed by assembly code */
#define	CPU_CONFIG_REG	         (SYSC_BASE + 0x0010)
#define	TEST_RESULT_REG	        (SYSC_BASE + 0x0018)
#define	TEST_RESULT2_REG	       (SYSC_BASE + 0x001C)
#define	RESET_STATUS_REG	       (SYSC_BASE + 0x0038)
#define	DLL_CONFIG_REG	         (SYSC_BASE + 0x004C)
//
///* Define of value for TEST_RESULT2_REG to indicate NMI exception */
#define	TEST_RESULT2_NMI	(0xC0000001)
//
//
///* Chip Name 0 & 1 register bit definitions */
#define	CHIPNAME0	              (0x70617247)   /* "Grap" */
#define	CHIPNAME1	              (0x65746968)   /* "hite" */
//
//
///* Chip ID register bit definitions */
#define	CHIP_REV_MASK	          (0xFFFF)
#define	CHIP_REV_SHIFT	         (0)
#define	CHIP_NUM_MASK	          (0xFFFF)
#define	CHIP_NUM_SHIFT	         (16)
//
#define	CHIP_REV	               (0x0000)
#define	CHIP_NUM	               (0x0000)
#define	CHIP_ID	                ((CHIP_NUM << CHIP_NUM_SHIFT) | (CHIP_REV << CHIP_REV_SHIFT))
//
///* CPU Config register bit definitions */
///* CPU Error Status register bit definitions */
#define	ALL_REMAP_BITS_MASK	(0x001F)
#define	REMAP_ROM	              (0x0001)
#define	REMAP_VECTMEM		(0x0002)	/* May not be implemented */
#define	REMAP_SDRAM2VEC		(0x0004)	/* May not be implemented */
#define	REMAP_SDRAM2ROM		(0x0008)	/* May not be implemented */
#define	REMAP_SRAM	   		(0x0010)	/* May not be implemented */
#define	ALL_CPU_ERRORS	         (0x0F80)
#define	CPU_DMA_ERROR	          (0x0080)
#define	CPU_DATA_ADDR_ERROR	    (0x0100)
#define	CPU_INST_ADDR_ERROR	    (0x0200)
#define	CPU_DATA_ALIGN_ERROR	   (0x0400)
#define	CPU_INST_ALIGN_ERROR	   (0x0800)
#define	PERIPH_8_AND_16_WR_ENA	 (0x1000)        /* Palmbus 8/16 bit writes */
#define	LCD_MUX_ENA	            (0x2000)        /* Enables muxed LCD signals */
#define	POST_WRITE_DIS	         (0x4000)        /* Palmbus postwrite disable */
//
#define	CPU_DATA_ERRORS	        (CPU_DATA_ADDR_ERROR | CPU_DATA_ALIGN_ERROR)
#define	CPU_INST_ERRORS	        (CPU_INST_ADDR_ERROR | CPU_INST_ALIGN_ERROR)
//
///* Bad Data Access Info register bit definitions */
#define	BAD_DATA_INFO_MASK	     (0x7F)
#define	BAD_DATA_BYTESEL_MASK	  (0x78)
#define	BAD_DATA_BYTESEL_SHIFT	 (3)
#define	BAD_DATA_DIR_MASK	      (0x04)
#define	BAD_DATA_SIZE_MASK	     (0x03)
//
#define	BAD_DATA_READ	          (0x00)
#define	BAD_DATA_WRITE	         (0x04)
//
#define	BAD_DATA_TYPE_MASK	     (0x07)	/* DIR and SIZE */
#define	BAD_BYTE_READ	          (0x00)
#define	BAD_WORD_READ	          (0x01)
#define	BAD_DWORD_READ	         (0x02)
#define	BAD_BYTE_WRITE	         (0x04)
#define	BAD_WORD_WRITE	         (0x05)
#define	BAD_DWORD_WRITE	        (0x06)
//
///* Bad Instruction Access Info register bit definitions */
#define	BAD_INST_INFO_MASK	     (0x3F)
#define	BAD_INST_BYTESEL_MASK	  (0x3C)
#define	BAD_INST_BYTESEL_SHIFT	 (2)
#define	BAD_INST_SIZE_MASK	     (0x03)
//
#define	BAD_BYTE_INST	          (0x00)
#define	BAD_WORD_INST	          (0x01)
#define	BAD_DWORD_INST	         (0x02)
//
///* Power Management, Clock Config register bit definitions */
#define	SYS_SLEEP_ENABLE	       (0x1)
#define	CPU_SLEEP_ENABLE	       (0x2)
//
///* Reset Control register bit definitions */
#define	RESET_SYSC	             (0x00000001)
#define	RESET_TMR	              (0x00000002)
#define	RESET_INTC	             (0x00000004)
#define	RESET_MAC	              (0x00000008)
#define	RESET_CPU	              (0x00000010)
#define	RESET_UART	             (0x00000020)
#define	RESET_PIO	              (0x00000040)
#define	RESET_DMA	              (0x00000080)
#define	RESET_LCD	              (0x00000100)
#define	RESET_I2C	              (0x00000200)
#define	RESET_RTC	              (0x00000400)
#define	RESET_SPI	              (0x00000800)
#define	RESET_UARTLITE	         (0x00001000)
#define	RESET_AUX0	             (0x00010000)
#define	RESET_AUX1	             (0x00020000)
#define	RESET_AUX2	             (0x00040000)
#define	RESET_AUX3	             (0x00080000)
#define	RESET_AUX4	             (0x00100000)
#define	RESET_AUX5	             (0x00200000)
#define	RESET_AUX6	             (0x00400000)
#define	RESET_AUX7	             (0x00800000)
#define	RESET_AUX8	             (0x01000000)
#define	RESET_AUX9	             (0x02000000)
#define	RESET_AUX10	            (0x04000000)
//
///* Reset Status register bit definitions */
#define	POR_RESET_STATUS	       (0)
#define	ALL_RESETS	             (0xF)
#define	EXT_PIN_RESET	          (0x1)
#define	WATCHDOG_RESET	         (0x2)
#define	SW_SYSTEM_RESET	        (0x4)
#define	SW_CPU_RESET	           (0x8)
//
///* PLL Control (pllCtrl) Register bit definitions */
#define	PLL_BYPASS			(0x00000001)
#define	PLL_ENABLE			(0x00000002)
#define	PLL_RESET			(0x00000004)
//
///* PLL Configuration (pllCfg) Register bit definitions */
#define	PLL_REFCLK_MDIV_MASK		(0xFF)
#define	PLL_REFCLK_MDIV_SHIFT		(0)
#define	PLL_FEEDBACK_NDIV_MASK		(0xFF)
#define	PLL_FEEDBACK_NDIV_SHIFT		(8)
//
///* PLL Status (pllStat) Register bit definitions */
#define	PLL_LOCKED			(0x00000001)
//
///* DLL Configuration (dllCfg) Register bit definitions */
#define	DLL_PHASE_MASK			(0x3)
#define	DLL_PHASE_SHIFT			(0)
#define	DLL_INVERT_SYSCLK		(0x00000004)
#define	DLL_ENABLE			(0x00000008)
//
#define	DLL_PHASE_0			(0x0)
#define	DLL_PHASE_90			(0x1)
#define	DLL_PHASE_180			(0x2)
#define	DLL_PHASE_270			(0x3)
//
//typedef enum dllPhase_t
//{
//    dllPhase0   = DLL_PHASE_0,
//    dllPhase90  = DLL_PHASE_90,
//    dllPhase180 = DLL_PHASE_180,
//    dllPhase270 = DLL_PHASE_270
//} dllPhase;
//
///* DLL Status (dllStat) Register bit definitions */
#define	DLL_LOCKED			(0x00000001)
///* Test Result register bit definitions */
///* This bit is set by the simulation scripts.  On POR reset, the bootstrap
//** code (sysboot.s) will check for this bit, set a variable if this bit is set,
//** and then clear this bit from the register.
//** Any code thereafter can check the variable, using SyscIsSimEnvironment(), to
//** determine if running in a simulation environment.
//** This is useful, for instance, to avoid running a delay loop in simulation,
//** if only real hardware requires firmware to delay.
//*/
#define	SIM_BIT			(0x1)
//
//
///*=====================*
// *  Type Defines       *
// *=====================*/
//
//typedef struct syscRegs_t 
//{
//    volatile uint32 chipName0;          /* 0x00 */
//    volatile uint32 chipName1;          /* 0x04 */
//    volatile uint32 reserved1;          /* 0x08 */
//    volatile uint32 chipId;             /* 0x0C */
//    volatile uint32 cpuConfig;          /* 0x10 */
//    volatile uint32 cpuErrStatus;       /* 0x14 */
//    volatile uint32 testResult;         /* 0x18 */
//    volatile uint32 testResult2;        /* 0x1C */
//    volatile uint32 badDataInfo;        /* 0x20 */
//    volatile uint32 badDataAddr;        /* 0x24 */
//    volatile uint32 badInstInfo;        /* 0x28 */
//    volatile uint32 badInstAddr;        /* 0x2C */
//    volatile uint32 clockConfig;        /* 0x30 */
//    volatile uint32 resetCtrl;          /* 0x34 */
//    volatile uint32 resetStatus;        /* 0x38 */
//    volatile uint32 reserved2;          /* 0x3C */
//    volatile uint32 pllCtrl;            /* 0x40 */
//    volatile uint32 pllCfg;             /* 0x44 */
//    volatile uint32 pllStat;            /* 0x48 */
//    volatile uint32 dllCfg;             /* 0x4C */
//    volatile uint32 dllStat;            /* 0x50 */
//} syscRegs;
//
//
///*=====================*
// *  External Variables *
// *=====================*/
//
//
///*=====================*
// *  External Functions *
// *=====================*/
///* The following functions are used for environment determination:
//** letting software know at run time whether code is running in simulation.
//*/
.extern	SyscSetSimEnvironment
.extern	SyscClearSimEnvironment
.extern	SyscIsSimEnvironment
.extern	SyscCalcByteSel
.extern	SyscPllEngage
.extern	SyscDllEngage
//
//
///*=====================*
// *  Macros Functions   *
// *=====================*/
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscEnableCpuErr()
////
//// SYNOPSIS       void SyscEnableCpuErr ( uint32 errbit )
////
//// TYPE           Macro
////
//// INPUT          uint32 errbit: bitmask for error to enable
////
//// OUTPUT         None
////
//// DESCRIPTION    This function enables cpu abort for the given cpu errors. 
////
//// NOTE           To avoid use of bitmasks, macros have also been defined for
////                enabling specific errors.
////
///******************************************************************************/
//#define SyscEnableCpuErr(errbit)   (((syscRegs*)SYSC_BASE)->cpuConfig |= (errbit))
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscEnableAllCpuErrors()
////                SyscEnableCpuDmaError()
////                SyscEnableCpuDataAddrError()
////                SyscEnableCpuInstAddrError()
////                SyscEnableCpuDataAlignError()
////                SyscEnableCpuInstAlignError()
////                SyscEnableCpuDataErrors()
////                SyscEnableCpuInstErrors()
////
//// SYNOPSIS       void SyscEnableAllCpuErrors ( void )
////                void SyscEnableCpuDmaError ( void )
////                void SyscEnableCpuDataAddrError ( void )
////                void SyscEnableCpuInstAddrError ( void )
////                void SyscEnableCpuDataAlignError ( void )
////                void SyscEnableCpuInstAlignError ( void )
////                void SyscEnableCpuDataErrors ( void )
////                void SyscEnableCpuInstErrors ( void )
////
//// TYPE           Macro
////
//// INPUT          None
////
//// OUTPUT         None
////
//// DESCRIPTION    These functions enable cpu abort for the given cpu error. 
////
//// NOTE           These macros use the macro SyscEnableCpuErr().
////
///******************************************************************************/
//#define SyscEnableAllCpuErrors()       SyscEnableCpuErr(ALL_CPU_ERRORS)
//#define SyscEnableCpuDmaError()        SyscEnableCpuErr(CPU_DMA_ERROR)
//#define SyscEnableCpuDataAddrError()   SyscEnableCpuErr(CPU_DATA_ADDR_ERROR)
//#define SyscEnableCpuInstAddrError()   SyscEnableCpuErr(CPU_INST_ADDR_ERROR)
//#define SyscEnableCpuDataAlignError()  SyscEnableCpuErr(CPU_DATA_ALIGN_ERROR)
//#define SyscEnableCpuInstAlignError()  SyscEnableCpuErr(CPU_INST_ALIGN_ERROR)
//#define SyscEnableCpuDataErrors()      SyscEnableCpuErr(CPU_DATA_ERRORS)
//#define SyscEnableCpuInstErrors()      SyscEnableCpuErr(CPU_INST_ERRORS)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscDisableCpuErr()
////
//// SYNOPSIS       void SyscDisableCpuErr ( uint32 errbit )
////
//// TYPE           Macro
////
//// INPUT          uint32 errbit: bitmask for error to disable
////
//// OUTPUT         None
////
//// DESCRIPTION    This function disables cpu abort for the given cpu errors. 
////
//// NOTE           To avoid use of bitmasks, macros have also been defined for
////                disabling specific errors.
////
///******************************************************************************/
//#define SyscDisableCpuErr(errbit)  (((syscRegs*)SYSC_BASE)->cpuConfig &= ~(errbit))
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscDisableAllCpuErrors()
////                SyscDisableCpuDmaError()
////                SyscDisableCpuDataAddrError()
////                SyscDisableCpuInstAddrError()
////                SyscDisableCpuDataAlignError()
////                SyscDisableCpuInstAlignError()
////                SyscDisableCpuDataErrors()
////                SyscDisableCpuInstErrors()
////
//// SYNOPSIS       void SyscDisableAllCpuErrors ( void )
////                void SyscDisableCpuDmaError ( void )
////                void SyscDisableCpuDataAddrError ( void )
////                void SyscDisableCpuInstAddrError ( void )
////                void SyscDisableCpuDataAlignError ( void )
////                void SyscDisableCpuInstAlignError ( void )
////                void SyscDisableCpuDataErrors ( void )
////                void SyscDisableCpuInstErrors ( void )
////
//// TYPE           Macro
////
//// INPUT          None
////
//// OUTPUT         None
////
//// DESCRIPTION    These functions disable cpu abort for the given cpu error. 
////
//// NOTE           These macros use the macro SyscDisableCpuErr().
////
///******************************************************************************/
//#define SyscDisableAllCpuErrors()       SyscDisableCpuErr(ALL_CPU_ERRORS)
//#define SyscDisableCpuDmaError()        SyscDisableCpuErr(CPU_DMA_ERROR)
//#define SyscDisableCpuDataAddrError()   SyscDisableCpuErr(CPU_DATA_ADDR_ERROR)
//#define SyscDisableCpuInstAddrError()   SyscDisableCpuErr(CPU_INST_ADDR_ERROR)
//#define SyscDisableCpuDataAlignError()  SyscDisableCpuErr(CPU_DATA_ALIGN_ERROR)
//#define SyscDisableCpuInstAlignError()  SyscDisableCpuErr(CPU_INST_ALIGN_ERROR)
//#define SyscDisableCpuDataErrors()      SyscDisableCpuErr(CPU_DATA_ERRORS)
//#define SyscDisableCpuInstErrors()      SyscDisableCpuErr(CPU_INST_ERRORS)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscClearCpuErr()
////
//// SYNOPSIS       void SyscClearCpuErr ( uint32 errbit )
////
//// TYPE           Macro
////
//// INPUT          uint32 errbit: bitmask for error to clear
////
//// OUTPUT         None
////
//// DESCRIPTION    This function clears the given cpu errors from the status. 
////
//// NOTE           To avoid use of bitmasks, macros have also been defined for
////                clearing specific errors.
////
///******************************************************************************/
//#define SyscClearCpuErr(errbit)    (((syscRegs*)SYSC_BASE)->cpuErrStatus = (errbit))
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscClearAllCpuErrors()
////                SyscClearCpuDmaError()
////                SyscClearCpuDataAddrError()
////                SyscClearCpuInstAddrError()
////                SyscClearCpuDataAlignError()
////                SyscClearCpuInstAlignError()
////                SyscClearCpuDataErrors()
////                SyscClearCpuInstErrors()
////
//// SYNOPSIS       void SyscClearAllCpuErrors ( void )
////                void SyscClearCpuDmaError ( void )
////                void SyscClearCpuDataAddrError ( void )
////                void SyscClearCpuInstAddrError ( void )
////                void SyscClearCpuDataAlignError ( void )
////                void SyscClearCpuInstAlignError ( void )
////                void SyscClearCpuDataErrors ( void )
////                void SyscClearCpuInstErrors ( void )
////
//// TYPE           Macro
////
//// INPUT          None
////
//// OUTPUT         None
////
//// DESCRIPTION    These functions clear the given cpu error from the status. 
////
//// NOTE           These macros use the macro SyscClearCpuErr().
////
///******************************************************************************/
//#define SyscClearAllCpuErrors()         SyscClearCpuErr(ALL_CPU_ERRORS)
//#define SyscClearCpuDmaError()          SyscClearCpuErr(CPU_DMA_ERROR)
//#define SyscClearCpuDataAddrError()     SyscClearCpuErr(CPU_DATA_ADDR_ERROR)
//#define SyscClearCpuInstAddrError()     SyscClearCpuErr(CPU_INST_ADDR_ERROR)
//#define SyscClearCpuDataAlignError()    SyscClearCpuErr(CPU_DATA_ALIGN_ERROR)
//#define SyscClearCpuInstAlignError()    SyscClearCpuErr(CPU_INST_ALIGN_ERROR)
//#define SyscClearCpuDataErrors()        SyscClearCpuErr(CPU_DATA_ERRORS)
//#define SyscClearCpuInstErrors()        SyscClearCpuErr(CPU_INST_ERRORS)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscSetCpuCfgBits()
////
//// SYNOPSIS       void SyscSetCpuCfgBits ( uint32 bits )
////
//// TYPE           Macro
////
//// INPUT          uint32 bits: bits to set in the cpu configuration
////
//// OUTPUT         None
////
//// DESCRIPTION    This function sets the given bits in the cpu configuration.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscSetCpuCfgBits(bits)   do { ((syscRegs*)SYSC_BASE)->cpuConfig |= (uint32)(bits); } while (0)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscClearCpuCfgBits()
////
//// SYNOPSIS       void SyscClearCpuCfgBits ( uint32 bits )
////
//// TYPE           Macro
////
//// INPUT          uint32 bits: bits to clear in the cpu configuration
////
//// OUTPUT         None
////
//// DESCRIPTION    This function clears the given bits in the cpu configuration.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscClearCpuCfgBits(bits)   do { ((syscRegs*)SYSC_BASE)->cpuConfig &= ~(uint32)(bits); } while (0)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscGetCpuCfg()
////
//// SYNOPSIS       uint32 SyscGetCpuCfg ( void )
////
//// TYPE           Macro
////
//// INPUT          None
////
//// OUTPUT         uint32: current cpu configuration
////
//// DESCRIPTION    This function returns the current cpu configuration.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscGetCpuCfg()   (((syscRegs*)SYSC_BASE)->cpuConfig)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscSetCpuCfg()
////
//// SYNOPSIS       void SyscSetCpuCfg ( uint32 cfg )
////
//// TYPE           Macro
////
//// INPUT          uint32 cfg: value to write to the cpu configuration register
////
//// OUTPUT         None
////
//// DESCRIPTION    This function sets the cpu configuration to the given value.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscSetCpuCfg(cfg)   do { ((syscRegs*)SYSC_BASE)->cpuConfig = (uint32)(cfg); } while (0)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscIsEnableAllCpuErrors()
////                SyscIsEnableAnyCpuErrors()
////                SyscIsEnableCpuDmaError()
////                SyscIsEnableCpuDataAddrError()
////                SyscIsEnableCpuInstAddrError()
////                SyscIsEnableCpuDataAlignError()
////                SyscIsEnableCpuInstAlignError()
////                SyscIsEnableCpuDataErrors()
////                SyscIsEnableCpuInstErrors()
////
//// SYNOPSIS       bool SyscIsEnableAllCpuErrors ( void )
////                bool SyscIsEnableAnyCpuErrors ( void )
////                bool SyscIsEnableCpuDmaError ( void )
////                bool SyscIsEnableCpuDataAddrError ( void )
////                bool SyscIsEnableCpuInstAddrError ( void )
////                bool SyscIsEnableCpuDataAlignError ( void )
////                bool SyscIsEnableCpuInstAlignError ( void )
////                bool SyscIsEnableCpuDataErrors( void )
////                bool SyscIsEnableCpuInstErrors( void )
////
//// TYPE           Macro
////
//// INPUT          None
////
//// OUTPUT         bool: TRUE if the error is enabled
////                      FALSE if the error is not enabled
////
//// DESCRIPTION    These functions indicate whether the given error is enabled.
////                If more than one error is checked
////                (ex. SyscIsEnableAllCpuErrors())
////                then all the errors must be enabled for the function to return
////                TRUE.
////
//// NOTE           These macros use the macro SyscGetCpuCfg().
////
///******************************************************************************/
//#define SyscIsEnableAllCpuErrors()       ((SyscGetCpuCfg() & ALL_CPU_ERRORS) == ALL_CPU_ERRORS)
//#define SyscIsEnableAnyCpuErrors()       ((bool)(SyscGetCpuCfg() & ALL_CPU_ERRORS))
//#define SyscIsEnableCpuDmaError()        ((bool)(SyscGetCpuCfg() & CPU_DMA_ERROR))
//#define SyscIsEnableCpuDataAddrError()   ((bool)(SyscGetCpuCfg() & CPU_DATA_ADDR_ERROR))
//#define SyscIsEnableCpuInstAddrError()   ((bool)(SyscGetCpuCfg() & CPU_INST_ADDR_ERROR))
//#define SyscIsEnableCpuDataAlignError()  ((bool)(SyscGetCpuCfg() & CPU_DATA_ALIGN_ERROR))
//#define SyscIsEnableCpuInstAlignError()  ((bool)(SyscGetCpuCfg() & CPU_INST_ALIGN_ERROR))
//#define SyscIsEnableCpuDataErrors()      ((SyscGetCpuCfg() & CPU_DATA_ERRORS) == CPU_DATA_ERRORS)
//#define SyscIsEnableCpuInstErrors()      ((SyscGetCpuCfg() & CPU_INST_ERRORS) == CPU_INST_ERRORS)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscGetCpuErrors()
////
//// SYNOPSIS       uint32 SyscGetCpuErrors ( void )
////
//// TYPE           Macro
////
//// INPUT          None
////
//// OUTPUT         uint32: value of the status register
////
//// DESCRIPTION    This function returns the current value of the error status
////                register.  This macro needs to be called only once to get the
////                value.  Pass the returned value into SyscIs*Error() macros to
////                check for errors.
////
//// NOTE
////
///******************************************************************************/
//#define SyscGetCpuErrors()         (((syscRegs*)SYSC_BASE)->cpuErrStatus)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscIsAnyCpuError()
////                SyscIsCpuDmaError()
////                SyscIsCpuDataAddrError()
////                SyscIsCpuInstAddrError()
////                SyscIsCpuDataAlignError()
////                SyscIsCpuInstAlignError()
////
//// SYNOPSIS       bool SyscIsAnyCpuError ( uint32 regval )
////                bool SyscIsCpuDmaError ( uint32 regval )
////                bool SyscIsCpuDataAddrError ( uint32 regval )
////                bool SyscIsCpuInstAddrError ( uint32 regval )
////                bool SyscIsCpuDataAlignError ( uint32 regval )
////                bool SyscIsCpuInstAlignError ( uint32 regval )
////
//// TYPE           Macro
////
//// INPUT          uint32 regval: value returned from SyscGetCpuErrors()
////
//// OUTPUT         bool: TRUE if the error is present
////                      FALSE if the error is not present
////
//// DESCRIPTION    These functions check whether the relevent error is present
////                in the given status.
////
//// NOTE
////
///******************************************************************************/
///* Using & since multiple bits can be set */
//#define SyscIsAnyCpuError(regval)       ((bool)((regval) & ALL_CPU_ERRORS))
//#define SyscIsCpuDmaError(regval)       ((bool)((regval) & CPU_DMA_ERROR))
//#define SyscIsCpuDataAddrError(regval)  ((bool)((regval) & CPU_DATA_ADDR_ERROR))
//#define SyscIsCpuInstAddrError(regval)  ((bool)((regval) & CPU_INST_ADDR_ERROR))
//#define SyscIsCpuDataAlignError(regval) ((bool)((regval) & CPU_DATA_ALIGN_ERROR))
//#define SyscIsCpuInstAlignError(regval) ((bool)((regval) & CPU_INST_ALIGN_ERROR))
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscEnablePeriph8and16Wr()
////
//// SYNOPSIS       void SyscEnablePeriph8and16Wr ( syscRegs *syscPtr )
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////
//// OUTPUT         None.
////
//// DESCRIPTION    Enable the byte write bit
////
//// NOTE           None.
////
///******************************************************************************/
//#define SyscEnablePeriph8and16Wr(syscPtr)   (syscPtr)->cpuConfig |= PERIPH_8_AND_16_WR_ENA
//
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscGetBadDataInfo()
////
//// SYNOPSIS       uint32 SyscGetBadDataInfo ( void )
////
//// TYPE           Macro
////
//// INPUT          None
////
//// OUTPUT         uint32: value of the bad data info register
////
//// DESCRIPTION    This function returns the current value of the bad data info
////                register.  This macro needs to be called only once to get the
////                value.  Pass the returned value into SyscIsBad*() macros to
////                check for the type of bad data.
////
//// NOTE
////
///******************************************************************************/
//#define SyscGetBadDataInfo()   (((syscRegs*)SYSC_BASE)->badDataInfo & BAD_DATA_INFO_MASK)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscIsBadRead()
////                SyscIsBadWrite()
////                SyscIsBadByteRead()
////                SyscIsBadWordRead()
////                SyscIsBadDwordRead()
////                SyscIsBadByteWrite()
////                SyscIsBadWordWrite()
////                SyscIsBadDwordWrite()
////
//// SYNOPSIS       bool SyscIsBadRead ( uint32 regval )
////                bool SyscIsBadWrite ( uint32 regval )
////                bool SyscIsBadByteRead ( uint32 regval )
////                bool SyscIsBadWordRead ( uint32 regval )
////                bool SyscIsBadDwordRead ( uint32 regval )
////                bool SyscIsBadByteWrite ( uint32 regval )
////                bool SyscIsBadWordWrite ( uint32 regval )
////                bool SyscIsBadDwordWrite ( uint32 regval )
////
//// TYPE           Macro
////
//// INPUT          uint32 regval: value returned from SyscGetBadDataInfo()
////
//// OUTPUT         bool: TRUE if the error is present
////                      FALSE if the error is not present
////
//// DESCRIPTION    These functions check which type of bad data error occurred.
////
//// NOTE
////
///******************************************************************************/
//#define SyscIsBadRead(regval)       (((regval) & BAD_DATA_DIR_MASK) == BAD_DATA_READ)
//#define SyscIsBadWrite(regval)      (((regval) & BAD_DATA_DIR_MASK) == BAD_DATA_WRITE)
//#define SyscIsBadByteRead(regval)   (((regval) & BAD_DATA_TYPE_MASK) == BAD_BYTE_READ)
//#define SyscIsBadWordRead(regval)   (((regval) & BAD_DATA_TYPE_MASK) == BAD_WORD_READ)
//#define SyscIsBadDwordRead(regval)  (((regval) & BAD_DATA_TYPE_MASK) == BAD_DWORD_READ)
//#define SyscIsBadByteWrite(regval)  (((regval) & BAD_DATA_TYPE_MASK) == BAD_BYTE_WRITE)
//#define SyscIsBadWordWrite(regval)  (((regval) & BAD_DATA_TYPE_MASK) == BAD_WORD_WRITE)
//#define SyscIsBadDwordWrite(regval) (((regval) & BAD_DATA_TYPE_MASK) == BAD_DWORD_WRITE)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscIsDataByteSelEqual()
////
//// SYNOPSIS       bool SyscIsDataByteSelEqual ( uint32 regval, uint32 bselBits )
////
//// TYPE           Macro
////
//// INPUT          uint32 regval: value returned from SyscGetBadDataInfo()
////                uint32 bselBits: 4-bit value indicating byte selects from cpu
////
//// OUTPUT         bool: TRUE if byte select status is equal to bselBits
////                      FALSE if byte select status is not equalt to bselBits
////
//// DESCRIPTION    This function compares the byte select status in the data info
////                register with the value of bselBits.
////
//// NOTE
////
///******************************************************************************/
//#define SyscIsDataByteSelEqual(regval, bselBits)  ((((regval) & BAD_DATA_BYTESEL_MASK) >> BAD_DATA_BYTESEL_SHIFT) == (bselBits))
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscGetBadInstInfo()
////
//// SYNOPSIS       uint32 SyscGetBadInstInfo ( void )
////
//// TYPE           Macro
////
//// INPUT          None
////
//// OUTPUT         uint32: value of the bad instruction info register
////
//// DESCRIPTION    This function returns the current value of the bad
////                instruction info register.  This macro needs to be called
////                only once to get the value.  Pass the returned value into
////                SyscIsBad*Inst() macros to check for the type of bad
////                instruction.
////
//// NOTE           
////
///******************************************************************************/
//#define SyscGetBadInstInfo()   (((syscRegs*)SYSC_BASE)->badInstInfo & BAD_INST_INFO_MASK)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscIsBadByteInst()
////                SyscIsBadWordInst()
////                SyscIsBadDwordInst()
////
//// SYNOPSIS       bool SyscIsBadByteInst ( uint32 regval )
////                bool SyscIsBadWordInst ( uint32 regval )
////                bool SyscIsBadDwordInst ( uint32 regval )
////
//// TYPE           Macro
////
//// INPUT          uint32 regval: value returned from SyscGetBadInstInfo()
////
//// OUTPUT         bool: TRUE if the error is present
////                      FALSE if the error is not present
////
//// DESCRIPTION    These functions check which type of instruction error
////                occurred.
////
//// NOTE
////
///******************************************************************************/
//#define SyscIsBadByteInst(regval)   (((regval) & BAD_INST_SIZE_MASK) == BAD_BYTE_INST)
//#define SyscIsBadWordInst(regval)   (((regval) & BAD_INST_SIZE_MASK) == BAD_WORD_INST)
//#define SyscIsBadDwordInst(regval)  (((regval) & BAD_INST_SIZE_MASK) == BAD_DWORD_INST)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscIsInstByteSelEqual()
////
//// SYNOPSIS       bool SyscIsInstByteSelEqual ( uint32 regval, uint32 bselBits )
////
//// TYPE           Macro
////
//// INPUT          uint32 regval: value returned from SyscGetBadInstInfo()
////                uint32 bselBits: 4-bit value indicating byte selects from cpu
////
//// OUTPUT         bool: TRUE if byte select status is equal to bselBits
////                      FALSE if byte select status is not equalt to bselBits
////
//// DESCRIPTION    This function compares the byte select status in the
////                instruction info register with the value of bselBits.
////
//// NOTE
////
///******************************************************************************/
//#define SyscIsInstByteSelEqual(regval, bselBits)  ((((regval) & BAD_INST_BYTESEL_MASK) >> BAD_INST_BYTESEL_SHIFT) == (bselBits))
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscGetBadDataAddr()
////
//// SYNOPSIS       uint32 SyscGetBadDataAddr ( void )
////
//// TYPE           Macro
////
//// INPUT          None
////
//// OUTPUT         uint32: value of the bad data address register
////
//// DESCRIPTION    This function returns the current value of the bad data
////                address register.  This is the address of the data which
////                caused a bad data error.
////
//// NOTE
////
///******************************************************************************/
//#define SyscGetBadDataAddr()   (((syscRegs*)SYSC_BASE)->badDataAddr)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscGetBadInstAddr()
////
//// SYNOPSIS       uint32 SyscGetBadInstAddr ( void )
////
//// TYPE           Macro
////
//// INPUT          None
////
//// OUTPUT         uint32: value of the bad instruction address register
////
//// DESCRIPTION    This function returns the current value of the bad instruction
////                address register.  This is the address of the instruction
////                which caused a bad instruction error.
////
//// NOTE
////
///******************************************************************************/
//#define SyscGetBadInstAddr()   (((syscRegs*)SYSC_BASE)->badInstAddr)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscCpu_Sleep()
////                SyscSys_Sleep()
////
//// SYNOPSIS       void SyscCpu_Sleep ( void )
////                void SyscSys_Sleep ( void )
////
//// TYPE           Macro
////
//// INPUT          None
////
//// OUTPUT         None
////
//// DESCRIPTION    These functions disables the clock inputs to the cpu or to
////                whole system.
////
//// NOTE           The sleep feature is not implemented in the standard
////                Palmpak 2 hardware.  It is an optional hardware feature.
////
///******************************************************************************/
//#define SyscCpu_Sleep()    (((syscRegs*)SYSC_BASE)->clockConfig = CPU_SLEEP_ENABLE)
//#define SyscSys_Sleep()    (((syscRegs*)SYSC_BASE)->clockConfig = SYS_SLEEP_ENABLE)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscResetBlk()
////
//// SYNOPSIS       void SyscResetBlk ( uint32 resetbit )
////
//// TYPE           Macro
////
//// INPUT          uint32 resetbit: bitmask for the block to reset
////
//// OUTPUT         None
////
//// DESCRIPTION    This function resets the given hardware block.
////
//// NOTE           To avoid use of bitmasks, macros have also been defined for
////                reseting specific blocks.
////
///******************************************************************************/
//#define SyscResetBlk(resetbit) (((syscRegs*)SYSC_BASE)->resetCtrl = (resetbit))
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscReset_System()
////                SyscReset_Cpu()
////                SyscReset_Block(block)
////
//// SYNOPSIS       void SyscReset_System ( void )
////                void SyscReset_Cpu ( void )
////                void SyscReset_Block ( block )
////
//// TYPE           Macro
////
//// INPUT          None for SyscReset_System() and SyscReset_Cpu()
////                For SyscReset_Block:
////                uint32 block:  must be a number equal to one of the block
////                               numbers defined in chip_reg_map.h
////                               TMR, UART, AUX0, AUX1, ... 
////
//// OUTPUT         None
////
//// DESCRIPTION    These functions reset the given hardware block.
////                If invalid block number is passed into SyscReset_Block(), no
////                block will be reset.
////
//// NOTE           These macros use the macro SyscResetBlk().
////
///******************************************************************************/
//#define SyscReset_System()          SyscResetBlk(RESET_SYSC)
//#define SyscReset_Cpu()             SyscResetBlk(RESET_CPU)
//
//#define SyscReset_Block(block)                                               \ 
//                       ( (block == SYSC)  ? SyscResetBlk(RESET_SYSC)  :      \ 
//                         (block == TMR)   ? SyscResetBlk(RESET_TMR)   :      \ 
//                         (block == INTC)  ? SyscResetBlk(RESET_INTC)  :      \ 
//                         (block == MAC)   ? SyscResetBlk(RESET_MAC)   :      \ 
//                         (block == UART)  ? SyscResetBlk(RESET_UART)  :      \ 
//                         (block == PIO)   ? SyscResetBlk(RESET_PIO)   :      \ 
//                         (block == DMA)   ? SyscResetBlk(RESET_DMA)   :      \ 
//                         (block == LCD)   ? SyscResetBlk(RESET_LCD)   :      \ 
//                         (block == I2C)   ? SyscResetBlk(RESET_I2C)   :      \ 
//                         (block == RTC)   ? SyscResetBlk(RESET_RTC)   :      \ 
//                         (block == SPI)   ? SyscResetBlk(RESET_SPI)   :      \ 
//                         (block == UARTLITE) ? SyscResetBlk(RESET_UARTLITE): \ 
//                         (block == AUX0)  ? SyscResetBlk(RESET_AUX0)  :      \ 
//                         (block == AUX1)  ? SyscResetBlk(RESET_AUX1)  :      \ 
//                         (block == AUX2)  ? SyscResetBlk(RESET_AUX2)  :      \ 
//                         (block == AUX3)  ? SyscResetBlk(RESET_AUX3)  :      \ 
//                         (block == AUX4)  ? SyscResetBlk(RESET_AUX4)  :      \ 
//                         (block == AUX5)  ? SyscResetBlk(RESET_AUX5)  :      \ 
//                         (block == AUX6)  ? SyscResetBlk(RESET_AUX6)  :      \ 
//                         (block == AUX7)  ? SyscResetBlk(RESET_AUX7)  :      \ 
//                         (block == AUX8)  ? SyscResetBlk(RESET_AUX8)  :      \ 
//                         (block == AUX9)  ? SyscResetBlk(RESET_AUX9)  :      \ 
//                         (block == AUX10) ? SyscResetBlk(RESET_AUX10) :      \ 
//                         SyscResetBlk(0) )
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscGetResetStatus()
////
//// SYNOPSIS       uint32 SyscGetResetStatus ( void )
////
//// TYPE           Macro
////
//// INPUT          None
////
//// OUTPUT         uint32: value of the reset status register
////
//// DESCRIPTION    This function returns the current value of the reset status
////                register.  This macro needs to be called only once to get the
////                value.  Pass the returned value into SyscIs*Reset() macros to
////                check for the type of reset.
////
//// NOTE
////
///******************************************************************************/
//#define SyscGetResetStatus()           (((syscRegs*)SYSC_BASE)->resetStatus)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscIsPORReset()
////                SyscIsExternalPinReset()
////                SyscIsWatchdogReset()
////                SyscIsSwSystemReset()
////                SyscIsSwCpuReset()
////
//// SYNOPSIS       bool SyscIsPORReset ( uint32 regval )
////                bool SyscIsExternalPinReset ( uint32 regval )
////                bool SyscIsWatchdogReset ( uint32 regval )
////                bool SyscIsSwSystemReset ( uint32 regval )
////                bool SyscIsSwCpuReset ( uint32 regval )
////
//// TYPE           Macro
////
//// INPUT          uint32 regval: value returned from SyscGetResetStatus()
////
//// OUTPUT         bool: TRUE if the reset is present
////                      FALSE if the reset is not present
////
//// DESCRIPTION    These functions check which type of reset occurred.
////
//// NOTE
////
///******************************************************************************/
//#define SyscIsPORReset(regval)         ((regval) == POR_RESET_STATUS)
///* Using & since multiple bits can be set */
//#define SyscIsExternalPinReset(regval) ((bool)((regval) & EXT_PIN_RESET))
//#define SyscIsWatchdogReset(regval)    ((bool)((regval) & WATCHDOG_RESET))
//#define SyscIsSwSystemReset(regval)    ((bool)((regval) & SW_SYSTEM_RESET))
//#define SyscIsSwCpuReset(regval)       ((bool)((regval) & SW_CPU_RESET))
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscClearResetStatus()
////
//// SYNOPSIS       void SyscClearResetStatus ( uint32 causebit )
////
//// TYPE           Macro
////
//// INPUT          uint32 causebit: bitmask of reset to clear
////
//// OUTPUT         None
////
//// DESCRIPTION    This function clears the given reset.
////
//// NOTE           To avoid use of bitmasks, macros have also been defined for
////                clearing specific resets.
////
///******************************************************************************/
//#define SyscClearResetStatus(causebit) (((syscRegs*)SYSC_BASE)->resetStatus = (causebit))
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscClearAllResets()
////                SyscClearExternalPinReset()
////                SyscClearWatchdogReset()
////                SyscClearSwSystemReset()
////                SyscClearSwCpuReset()
////
//// SYNOPSIS       void SyscClearAllResets ( void )
////                void SyscClearExternalPinReset ( void )
////                void SyscClearWatchdogReset ( void )
////                void SyscClearSwSystemReset ( void )
////                void SyscClearSwCpuReset ( void )
////
//// TYPE           Macro
////
//// INPUT          None
////
//// OUTPUT         None
////
//// DESCRIPTION    These functions clear the given resets.
////
//// NOTE
////
///******************************************************************************/
//#define SyscClearAllResets()           SyscClearResetStatus(ALL_RESETS)
//#define SyscClearExternalPinReset()    SyscClearResetStatus(EXT_PIN_RESET)
//#define SyscClearWatchdogReset()       SyscClearResetStatus(WATCHDOG_RESET)
//#define SyscClearSwSystemReset()       SyscClearResetStatus(SW_SYSTEM_RESET)
//#define SyscClearSwCpuReset()          SyscClearResetStatus(SW_CPU_RESET)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscPllSetBypass()
////
//// SYNOPSIS       void SyscPllSetBypass(syscRegs *syscPtr)
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////
//// OUTPUT         None
////
//// DESCRIPTION    This function bypasses the pll and selects the external clock
////                as the system clock.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscPllSetBypass(syscPtr)                                             \ 
//do                                                                            \ 
//{                                                                             \ 
//     (syscPtr)->pllCtrl |= PLL_BYPASS;                                        \ 
//} while (0)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscPllClearBypass()
////
//// SYNOPSIS       void SyscPllClearBypass(syscRegs *syscPtr)
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////
//// OUTPUT         None
////
//// DESCRIPTION    This function selects the pll clock as the system clock.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscPllClearBypass(syscPtr)                                           \ 
//do                                                                            \ 
//{                                                                             \ 
//     (syscPtr)->pllCtrl &= ~PLL_BYPASS;                                       \ 
//} while (0)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscPllEnable()
////
//// SYNOPSIS       void SyscPllEnable(syscRegs *syscPtr)
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////
//// OUTPUT         None
////
//// DESCRIPTION    This function enables the pll.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscPllEnable(syscPtr)                                                \ 
//do                                                                            \ 
//{                                                                             \ 
//    (syscPtr)->pllCtrl |= PLL_ENABLE;                                         \ 
//} while (0)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscPllDisable()
////
//// SYNOPSIS       void SyscPllDisable(syscRegs *syscPtr)
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////
//// OUTPUT         None
////
//// DESCRIPTION    This function disables the pll.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscPllDisable(syscPtr)                                               \ 
//do                                                                            \ 
//{                                                                             \ 
//    (syscPtr)->pllCtrl &= ~PLL_ENABLE;                                        \ 
//} while (0)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscPllReset()
////
//// SYNOPSIS       void SyscPllReset(syscRegs *syscPtr)
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////
//// OUTPUT         None
////
//// DESCRIPTION    This function puts the pll in the reset state.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscPllReset(syscPtr)                                                 \ 
//do                                                                            \ 
//{                                                                             \ 
//    (syscPtr)->pllCtrl |= PLL_RESET;                                          \ 
//} while (0)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscPllClearReset()
////
//// SYNOPSIS       void SyscPllClearReset(syscRegs *syscPtr)
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////
//// OUTPUT         None
////
//// DESCRIPTION    This function takes the pll out of the reset state.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscPllClearReset(syscPtr)                                            \ 
//do                                                                            \ 
//{                                                                             \ 
//    (syscPtr)->pllCtrl &= ~PLL_RESET;                                         \ 
//} while (0)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscPllSetCfg()
////
//// SYNOPSIS       void SyscPllSetCfg(syscRegs *syscPtr, uint32 cfg)
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////                uint32 cfg: value for the configuration register
////
//// OUTPUT         None
////
//// DESCRIPTION    This function sets the the configuration for the pll.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscPllSetCfg(syscPtr, cfg)                                           \ 
//do                                                                            \ 
//{                                                                             \ 
//     (syscPtr)->pllCfg = (cfg);                                               \ 
//} while (0)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscPllGetCfg()
////
//// SYNOPSIS       uint32 SyscPllGetCfg(syscRegs *syscPtr)
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////
//// OUTPUT         uint32: value of the configuration register
////
//// DESCRIPTION    This function reads the the current configuration for the pll.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscPllGetCfg(syscPtr)   ((syscPtr)->pllCfg)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscPllIsLocked()
////
//// SYNOPSIS       bool SyscPllIsLocked(syscRegs *syscPtr)
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////
//// OUTPUT         bool: TRUE if pll status indicates it is locked and ready to
////                      be used
////                      FALSE if pll not locked
////
//// DESCRIPTION    This function checks whether the pll output is locked and
////                ready to be used.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscPllIsLocked(syscPtr)    ((bool)((syscPtr)->pllStat & PLL_LOCKED))
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscPllResetAll()
////
//// SYNOPSIS       void SyscPllResetAll(syscRegs *syscPtr)
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////
//// OUTPUT         None
////
//// DESCRIPTION    This function resets the pll control to its power-on reset
////                state.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscPllResetAll(syscPtr)                                              \ 
//do                                                                            \ 
//{                                                                             \ 
//     (syscPtr)->pllCtrl |= PLL_BYPASS;                                        \ 
//     (syscPtr)->pllCtrl = PLL_BYPASS | PLL_RESET;                             \ 
//} while (0)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscDllEnable()
////
//// SYNOPSIS       void SyscDllEnable(syscRegs *syscPtr)
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////
//// OUTPUT         None
////
//// DESCRIPTION    This function enables the dll.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscDllEnable(syscPtr)                                                \ 
//do                                                                            \ 
//{                                                                             \ 
//    (syscPtr)->dllCfg |= DLL_ENABLE;                                          \ 
//} while (0)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscDllDisable()
////
//// SYNOPSIS       void SyscDllDisable(syscRegs *syscPtr)
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////
//// OUTPUT         None
////
//// DESCRIPTION    This function disables the dll.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscDllDisable(syscPtr)                                               \ 
//do                                                                            \ 
//{                                                                             \ 
//    (syscPtr)->dllCfg &= ~DLL_ENABLE;                                         \ 
//} while (0)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscDllSetCfg()
////
//// SYNOPSIS       void SyscDllSetCfg(syscRegs *syscPtr, uint32 cfg)
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////                uint32 cfg: value for the configuration register
////
//// OUTPUT         None
////
//// DESCRIPTION    This function sets the the configuration for the dll.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscDllSetCfg(syscPtr, cfg)                                           \ 
//do                                                                            \ 
//{                                                                             \ 
//     (syscPtr)->dllCfg = (cfg);                                               \ 
//} while (0)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscDllGetCfg()
////
//// SYNOPSIS       uint32 SyscDllGetCfg(syscRegs *syscPtr)
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////
//// OUTPUT         uint32: value of the configuration register
////
//// DESCRIPTION    This function reads the the current configuration for the dll.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscDllGetCfg(syscPtr)   ((syscPtr)->dllCfg)
//
//
///* FUNCTION_DESC **************************************************************/
////
//// NAME           SyscDllIsLocked()
////
//// SYNOPSIS       bool SyscDllIsLocked(syscRegs *syscPtr)
////
//// TYPE           Macro
////
//// INPUT          syscRegs *syscPtr: Base Pointer of the System Controller
////                                   Register
////
//// OUTPUT         bool: TRUE if dll status indicates it is locked and ready to
////                      be used
////                      FALSE if dll not locked
////
//// DESCRIPTION    This function checks whether the dll output is locked and
////                ready to be used.
////
//// NOTE           None
////
///******************************************************************************/
//#define SyscDllIsLocked(syscPtr)    ((bool)((syscPtr)->dllStat & DLL_LOCKED))
//
//
#endif

